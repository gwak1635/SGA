#pragma once

#include "../Define/GlobalDefine.h"

/*
사용자 정의 자료형은 쉽게말해 프로그래머가 임의의 자료형을 만들어낼수 있는 기능을 말하며

다양한 변수를 묶거나 상수에 새로운 이름을 부여하는것도 가능하다.

다양한 변수를 묶는기능이면 class가 있는데 굳이 새로운 자료형을 만들어야 하나 싶을 수
있지만, class보다 가볍기 때문에 새로운 자료형을 만드는것은 의미가 있다.

다양한 변수를 묶어두는 기능을 struct라 부르며,
일반적으로 struct는 함수가 들어가지 않는 클래스라 생각하면 된다.

즉, 변수들만 들어있는 class 같은거다.

class와 추가적인 차이점은 class가 기본적으로 내부의 데이터를 private으로 보호한다면,
struct는 public등급 즉, 외부에서 접근할수있는 수준으로 보호하고 있다.

이러한 struct는 주로 클래스 내부에서 따로 묶어둘 변수들을 만드는데 사용된다.

만약 특정 클래스의 변수들을 struct로 묶어 뒀을때 추가로 같은 묶음에 들어갈 변수가
만들어졌다면, 

이전에는 해당 변수도 외부에 사용되기 위해서 해당 변수의 getter와 setter을 만들어야 
되지만 struct 내부에 추가 할경우 해당 struct 하나를 getter하고 setter하는거 만 
있으면 되다보니 추가적은 함수를 만들어 않아도 된다.

Ex)
int aValue; // aValue의 getter와 setter
int bValue; // bValue의 getter와 setter 즉 4개의 함수를 추가로 만들어야 하지만

struct Values
{
    int aValue;
    int bValue;
}

Values values; // values의 getter 와 setter만 있어요 내부의 aValue와 bValue에
전부 접근할수있다.

struct는 구조체라고도 부른다.

상수에 새로운 이름을 부여하는 기능은 enum이라 부르고, 한국어로는 열거형이라 한다.

열거형은 이름 그대로 문자를 열거 한뒤 해당 문자들에 숫자(상수)를 부여하는 역할을 하며

문자 뒤에 = 을 붙어 해당 문자에 숫자를 하나하나 넣을수도 있고
=을 통해 숫자를 집어넣지 않았다면 이전의 숫자보다 1큰수를 자동으로 부여받는다.
// 만약 첫번째라면 0을 붙여받는다.

Ex)

enum ItemType
{
    WEAPON = 100,
    SWORD,          // 자동으로 101
    GUN,            // 자동으로 102
    KATANA,         // 자동으로 103

    ARMOR = 200,
    FULL_PLATE,     // 자동으로 201
    ROBE            // 자동으로 202
}

열거형은 숫자에 해당 문자의 역할을 부여하는 느낌보단
해당 문자를 적으면 그자리에 정해진 숫자가 들어가는 느낌이라 생각해야한다.

또한 상수이기때문에 이전에 사용하던 배열에서 해당 enum으로 선언한 문자를 사용해
배열의 크기를 정할수있다.

기존의 enum은 enum으로 정의한 문자가 인식되는 범위가 제한되어지 않아 다른 enum에서
같은 이름의 문자를 사용하면 상수를 정의하는것이다보니 값을 수정할수 없기에 에러가
발생했다.

이러한 문제를 해결하고자 enum 또한 class를 사용해 특정한 이름을 지닌 구역으로 나누게
되었다. 이러한 class 를 사용하는 enum을 스코프드 열거형 // 조준경이 있는 열거형
class를 사용하지 않는 enum을 언스코프드 열거형 이라부르게 되었다.

Ex)
enum class ShopInfo // enum 뒤에 class를 붙이면 스코프드 열거형
{

}

스코프드 열거형은 시스템으로 언스코프드 열거형보다 좋은점밖에 없지만 실제로 사용하기 위해서

언스코프드의 경우 그냥 해당 문자를 입력하면 자동으로 enum에 들어있는 상수로 변환이
되었지만,

스코프드의 경우 해당 열거형의 이름을 선언한뒤 ::(맴버 접근 지정자)를 사용하여
해당 스코프드 열거형이 가지고있는 문자에 접근하여 사용을 해야 된다.

클래스에 접근하여 상수를 가져오는 기능이기때문에 일부 상수만 요구하는 곳에서 사용할수
없기도 하다.

열거형의 경우 일반적으로 특정 아이템 타입을 분류하는데 사용되기도 하지만

AI의 행동 패턴을 담당알 FSM 알고리즘에 핵심으로 작용하기도 하고,
플레이어의 특정 행동을 파악해 switch문을 바꿔줄 키워드로 사용되기도 한다.
*/

// 여기에다가 스트럭트나 이넘을 만들면,
// 전역 변수로 만들어지다보니 어느곳이든 접근할 수 있어
// 사용이 불편할 수 있기 때문에 여기에다가 만들지 않음

enum ValueType
{
    INT_VALUE = 0,  // = 0을 했기 때문에 0이 부여됨
    FLOAT_VALUE,    // 0 보다 1 큰수인 1이 부여됨
    CHAR_VALUE,     // 1 보다 1 큰수인 2가 부여됨
    MAX_VALUE = 10, // = 10을 했기 때문에 10이 부여됨
    MAX_PLUS_VALUE  // 10 보다 1 큰수인 11이 부여됨
};

enum class InfoType
{
    INT_INFO,       // 아무것도 입력하지 않으면 기본값으로 0이 부여됨
    FLOAT_INFO,
    CHAR_INFO
};

class E10
{
public:
    // 함수의 매게변수에 기본값을 넣는것이 가능하다.
    // 이렇게 매게변수에 기본값을 넣어주면 해당
    // 매게변수를 받는 위치에 따로 값이 입력되지 않을경우
    // 자동으로 기본값이 들어간다.
    // 이때, 기본값을 넣은 매게변수 뒤에 있는
    // 모든 매게변수또한 기본값을 가지고 있어야 한다
    // 즉, 중간에 있는 매게변수의 기본값만 넣는것은
    // 불가능하다.
    E10(int aValue = 0, int bValue = 0, int cValue = 0);
    ~E10();

    struct E10Info
    {
        int aValue = 0;
        int bValue = 0;
        int cValue = 0;
    };
    
    // struct는 Get만해도 해당 요소에 접근해 값을
    // 바꿀수 있기 때문에 따로 Set은 만들지 않았다.
    E10Info GetInfo()           { return info; }

    InfoType GetInfoType()      { return infoType; }

    void SetInfoType(InfoType infoType)
    { this->infoType = infoType; }
    
    ValueType GetValueType()    { return valueType; }

    void SetValueType(ValueType valueType) 
    { this->valueType = valueType; }

private:
    E10Info info;

    InfoType infoType = InfoType::INT_INFO;
    ValueType valueType = INT_VALUE;
};

/*
과제! 오목 과 AI 만들기 

조건1. 최소 5X5 이상의 오목판
조건1_1. 플레이어가 오목판 위에 돌을 둘 좌표를 입력받고
조건1_2. 해당 좌표에 플레이어 돌을 둔다
// 돌의 모양은 자유롭게 가능함 단, AI의 돌과는 달아야함 O X // 0 @ // 등등

조건2. 대각선 포함 5개가 연속으로 있을경우 게임 승리

================================================= 난이도 : 하

추가 조건1. 기초적은 AI 만들기
추가 조건1_1. 플레이어가 돌을 두고나면 빈칸중 랜덤한 곳에 AI 돌 배치

추가 조건2. AI 승리 구현

================================================= 난이도 : 중

하드 조건1. 승리지향 AI 만들기
하드 조건1_1. AI는 첫돌의 경우 랜덤한 위치에 돌을 배치
하드 조건1_2. 이미 배치된 돌이 있을경우 해당 돌과 인접한 빈공간에 돌 배치
하드 조건1_3. 만약 2개 이상의 연속된 돌이 배치되었을경우 해당 돌들의 연속된 방향에
추가 돌 배치
하드 조건1_4. 돌을 연속된 방향에 둘수 없다면 다시 랜덤한 빈 공간에 돌 배치

================================================= 난이도 : 상

헬 조건1. 승리지향 고성능 AI 만들기
헬 조건1_1. 자신의 승리 조건에 맞추기 전에 플레이어 돌 배치 확인
헬 조건1_2. 플레이어가 3개 이상의 연속된 돌을 뒀을경우 해당 배치를 방해하는 위치에
돌을 배치
// 아마 2칸 빈공간 2칸같이 떨어져있으면 인식 못할수있음 이건 ㅇㅈ

================================================= 난이도 : 극
*/