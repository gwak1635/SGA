#include "E06.h"

void E06()
{
    // int형 변수 5개를 넣을수 있는 aValues
    // 사실상 변수보단 데이터를 넣을수있다고 보는게 더 적절함
    int aValues[5];
    
    int aValue = 10;

    // 각각의 번호에 데이터를 하나씩 넣음
    aValues[0] = aValue;    // aValues 0번 위치에 aValue 값을 넣는다.
    aValues[1] = 20;        // aValues 1번 위치에 20을 넣는다.
    aValues[2] = 30;
    aValues[3] = 40;
    aValues[4] = 50;        // 배열의 번호는 배열의 크기보다 1 작은 값

    // 한번에 데이터를 넣음
    int bValues[5] = { 0,1,2,3,4 };

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", aValues[i]);
    }
    printf("\n");

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", bValues[i]);
    }
    printf("\n");

    // 배열의 초기화
    // {}를 통해 배열에 초기값을 집어넣을경우
    // 컴파일러는 자동으로 부족값을 0으로 채워넣는다.
    // 그렇기에 첫번째 값으로 0을 주고 나머지를 적지 않으면
    // 부족한 나머지 값들이 전부 0이 되며 모든 값을 0 으로 넣을수 있다.
    int cValues[5] = { 0 };

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", cValues[i]);
    }
    printf("\n");

    // 배열의 크기를 명시하지 않고 초기값을 넣었을경우
    // 컴파일러는 자동으로 해당 배열의 크기를 초기 값의 개수로 정한다.
    // 만약 초기값으로 5개의 데이터를 줬다면 그 배열의 크기는 자동으로
    // 5가 되는것이다.
    int dValues[] = { 5,6,7 };

    // 만약 해당 배열의 크기를 모르는 상태에서 해당 배열의 크기만큼만
    // 반복을 하고 싶을때 아래의 계산식을 사용하면 된다.
    // sizeof는 해당 변수가 얼마만큼의 메모리를 가지고 있는지
    // 알려주는 기능이고, 배열의 경우 반드시 0번째 데이터는 있기 때문에
    // 배열의 총 메모리 크기 / 1개의 데이터 크기를 계산하면
    // 해당 배열의 인덱스 개수를 알수있다.
    const int dSize = sizeof(dValues) / sizeof(dValues[0]);
    // Ex) dValues가 int 5개를 가지고 있는 배열이라면
    // dValues의 메모리 크기는 4Byte * 5 즉 20의 메모리를 가지고 있고
    // dValues[0]는 int 메모리의 4Byte를 가지고 있을태니
    // 20 / 4 하면 5가 나온다.

    for (int i = 0; i < dSize; i++)
    {
        printf("%d ", dValues[i]);
    }
    printf("\n");

    /*
    배열을 배열에 집어넣는 것을 다차원 배열이라 부른다.

    다차원 배열로 들어갈경우 마치 좌표값은 공간이 만들이지며, 이러한 공간을
    메트릭스라 부른다. // 참고로 배열은 Array라 부른다.

    이때 일반적인 좌표는 x,y,z 순으로 읽겠지만 배열의 경우 가장 뒤가
    x축, 그 앞이 y축, 그 앞이 z 축 순서로 들어간다.

    그리고 코드상의 공간이기 때문에 4차원이나 100차원 같은것도 충분히 만들수
    있다.
    */

    // 각각의 칸에 값 넣기
    int aMatrix[2][2];
    aMatrix[0][0] = 1;  // 0번째 줄의 0번째 칸에 1을 넣는다.
    aMatrix[0][1] = 2;
    aMatrix[1][0] = 3;
    aMatrix[1][1] = 4;  // 1번째 줄의 1번째 칸에 4를 넣는다.

    for (int i = 0; i < 2; i++) // Row // 행
    {
        for (int j = 0; j < 2; j++) // Col // 열
        {
            printf("%d ", aMatrix[i][j]);
        }
        printf("\n");
    }

    // 한줄씩 집어넣기
    int bMatrix[2][2] =
    {
        {10 , 20},
        {30 , 40}
    };

    // 가장 앞에있는 인덱스의 크기는 안적을수도 있음
    int cMatrix[][3] =
    {
        {10,20,30},
        {20,30,40}
    };

    // 행의 개수
    const int cRow = sizeof(cMatrix) / sizeof(cMatrix[0]);
    // 열의 개수
    const int cCol = sizeof(cMatrix[0]) / sizeof(cMatrix[0][0]);

    for (int i = 0; i < cRow; i++)
    {
        for (int j = 0; j < cCol; j++)
        {
            printf("%d ", cMatrix[i][j]);
        }
        printf("\n");
    }
}

/*
과제! 배열 내부 탐색하기

조건1. 10의 크기를 가지고 있는 배열 만들기
조건1_1. 해당 배열에 특정 숫자 랜덤하게 집어넣기
0 = 길, 1 = 일반 몬스터, 2 = 정예 몬스터, 3 = 보물상자, 4 = 이벤트
조건1_2. 배열의 0번째 위치에 플레이어(9)가 있어야 하며,
배열의 마지막 위치에는 보스 몬스터(5)가 있어야 한다.
5 = 보스 몬스터, 9 = 플레이어

Ex) 
맵 상황!
[ 9 1 0 1 1 2 0 3 4 0 5 ]
0 = 길, 1 = 일반 몬스터, 2 = 정예 몬스터, 3 = 보물상자, 4 = 이벤트
5 = 보스 몬스터, 9 = 플레이어

조건2. 플레이어가 숫자 1을 입력하면 0번째 위치에 있던 플레이어가
다음 인덱스칸으로 이동하기
조건2_1. 플레이어가 지나간 자리는 8로 표시하기

Ex)
맵 상황!
[ 8 8 9 1 1 2 0 3 4 0 5 ]
0 = 길, 1 = 일반 몬스터, 2 = 정예 몬스터, 3 = 보물상자, 4 = 이벤트
5 = 보스 몬스터, 8 = 이동한 위치, 9 = 플레이어

행동을 입력해 주세요 1. 이동 : 

==================== 여기까지 난이도 : 하

추가 조건1. 플레이어가 진입한 배열의 숫자에 따라 이벤트 발생하기
몬스터 = 전투 , 보물 상자 = 보상 & 스텟 증가 ,
이벤트 = 특수 상황 // 여러분이 원하는 대로 해도 됨
추가 조건1_2. 각각의 이벤트 발생시 해당 진행 상황을 콘솔창에 출력하기
몬스터와 전투 = 전투 로그 출력 , 보물 상자 = 뭘 얻었는지,
이벤트 = 대화 로그 & 상황 연출

추가 조건2. 2차원 배열로 기존의 배열을 3개 이상 가지고 있는 배열로 만들어
마지막에 있는 보스 몬스터(5) 처치시 다음 줄로 이동하기

Ex) 
맵 상황!
[ 8 8 9 1 1 2 0 3 4 0 5 ] <- 여기있는 보스 잡으면
[ 1 3 0 2 0 3 1 0 1 0 5 ] <- 여기 0번칸으로 플레이어 옮기기
[ 0 1 3 1 0 1 0 0 3 0 5 ]
0 = 길, 1 = 일반 몬스터, 2 = 정예 몬스터, 3 = 보물상자, 4 = 이벤트
5 = 보스 몬스터, 8 = 이동한 위치, 9 = 플레이어

추가 조건2_1. 가장 마지막줄 맨 끝에 있는 몬스터는 일반 보스 몬스터가
아니여도 된다.

==================== 여기까지 난이도 : 중

하드 조건1. 기존의 배열을 버리고 2차원 배열 최소 5X5 사이즈 만들기
하드 조건1_1. 기존과 동일한 기능을 할 숫자들
(0 ~ 5)에 추가로 7(벽)추가 하기

[0 0 1 0 7]
[1 7 0 5 3]
[4 0 9 2 4]
[0 0 1 0 7]
[1 7 0 0 3]

하드 조건 2. W,A,S,D 로 배열 이동하기
하드 조건 2_1. W를 누를시 배열의 윗칸으로, S누르면 아랫칸으로,
A와 D는 각각의 방향인 옆칸으로 이동하기
하드 조건 2_2. 단, 이동할 방향이 벽(7)이거나 배열의 밖일경우
이동하지 못하게 하기

[0 0 1 0 7]
[1 7 0 5 3]
[4 0 9 2 4]
[0 0 1 0 7]
[1 7 0 0 3]

플레이어가 W 눌렀을때

[0 0 1 0 7]
[1 7 9 5 3]
[4 0 0 2 4]
[0 0 1 0 7]
[1 7 0 0 3]

하드 조건3. 플레이어가 이동한 위치는 8이 아닌 0으로 표시하기
*/