#pragma once

#include "../Define/GlobalDefine.h"

/*
C와 C++은 근본적으로 코드적인 차이는 존재하지 않으며,
이 둘을 나누는것은 코드를 쓰는 방식과 프로그래머의 생각의 변화였다.

기존의 C는 필요한 기능들을 위에서부터 하나씩 만들어가며
아래로 계속 이어지는 방식인 [절차적 프로그래밍]을 사용해 왔고

C++은 C와 달리 필요한 기능을 할 새로운 '객체'라는 것을 만들어
해당 객체들이 서로 상호작용을 하며 프로그래밍이 만들어지는
[객체 지향형 프로그래밍]을 사용하는 것이다.

객체는 프로그래밍에서 사용될 하나의 개념으로 존재하며,
각각의 객체는 자신이 해야되는 일과 하지 말아야하는 일을 구분해야 하고
객체들은 서로 간섭하거나 다른 객체를 제어함에 있어서 합당안 논리적 이유가
있어야 할것이다.

그렇기때문에 C++의 객체지향은 프로그래머가 코딩을 더욱 쉽게하기 위해
만들어놓은 개념이 아닌 당장의 코딩은 어렵더라도 그 이후의 유지보수와
디버깅이 압도적으로 쉬워지는 방식이기 때문에 지금까지 사용되고 있다.

특히 게임같이 수많은 객체가 존재하고 해당 객체들이 각각 자신들의 만의
행동과 상호작용을 하는 프로그램이라면 더더욱 객체지향 프로그래밍을 사용할수
밖에 없다.

간단한 예시로 플레이어와 몬스터가 전투를 하는 프로그램이 있다고 했을때

이전에 사용하던 C의 절차적 방식이면 프로그램 가장 위에다가 변수들로
몬스터와 플레이어의 스텟들을 입력해둔뒤 그 아래에 조건문과 반복문들로
스텟을 더하고 빼고 하는식으로 전투를 만들수 있고
만약 전투가 다양한 상황에서 반복된다면 해당 기능들을 함수로 묶어서
사용할수도 있을것이다.

이러한 프로그램을 C++의 객체지향 프로그래밍으로 바꾼다면
우선 플레이어의 스텟과 공격하는 기능을 가지고있는 객체와
몬스터의 스텟과 공격하는 기능, 죽는기능같은 몬스터가 할 행동을 가지고 있는
객체를 만들어야 할것이며,
해당 객체들을 만든후에 각각의 객체를 메인 프로그램으로 가져와서
플레이어와 몬스터가 할 행동을 각각 지정해줘야 한다.
그리고 만약 게임처럼 시작과 끝이 있다면 해당 시작과 끝을 담당할
통칭 매니저라 부르는 시스템 객체를 만들어 해당 매니저가 플레이어를 생성하고
몬스터를 생성하고 죽으면 리스폰도 시키는 등 다양한 역할도 해줘야 할것이다.
*/

/*
c++에서 위에 설명한것과 같은 객체를 구현하기 위해 class 라는 새로운
자료형을 만들어 냈다.

class는 기본적으로 함수와 변수 전부 담을수 있으며, 해당 클래스를 통해
객체를 구현한다.

class는 4가지 특징을 가진것으로 유명한데,
기본적으로 불필요한 데이터를 외부에 숨기는 추상화,
특정 클래스끼리 부모 자식관계를 만들어 부모의 코드를 자식에게 물려주는 상속,
같은 이름의 객체를 다양한 방식으로 만들수있게 하는 다형성,
외부에서 접근하는것을 제한하고 데이터를 보호,은닉하는 캡슐화가 존재한다.

여기서 추상화와 캡슐화는 근복적으로 큰 차이가 없기때문에 3가지 특징이라고도 한다.

우선적으로 알아볼것은 클래스가 가진 데이터에대한 보호와 은닉이다.

클래스는 기본적으로 자신 내부에 선언된 다양한 함수와 변수에 특정한 보호 등급을
부여하는데 보호 등급에 따라 해당 데이터를 사용할수있는 대상이 결정된다.

public은 모두가 접근할수 있다. 라는 보호 등급이며 클래스의 내부, 외부에서
해당 데이터를 전부 사용할수있다.

protected는 자신과 지식이 접근할수 있다. 라는 보호 등급이며, 클래스의 내부와
해당 클래스를 상속받는 자식이 해당 데이터들을 사용할 수 있다.

마지막으로 private 등급은 자기 자신만 사용할 수 있는 데이터라는 뜻이고
private등급으로 보호받는 데이터들은 어떠한 경우에서도 외부에서 접근할 수 없다.

또한 클래스는 기본적으로 아무런 보호등급을 선언하지 않았을때 자신의 가지는
데이터들을 private등급으로 보호한다.

그렇기에 만약 자기 자신말고 다른 외부에서 해당 데이터들을 사용하게 해주고 싶으면
반드시 필요에따라 public이나 protected를 적어줘야 한다.

그리고 프로그래밍을 하다보면 private등급으로 보호받고있는 데이터들을 수정하거나
가져와야하는 경우가 발생하기 쉬운데, 이때 public에 해당 데이터를 수정하거나
가져오는 함수를 만들어 사용하게 일반적이며

가져오는 함수는 Getter, 수정하는 함수는 Setter 라 부른다.
*/

// E09라는 이름의 클래스를 만들었다.
class E09
{
// 자신이 원하는 보호등급과 :(콜론)을 적어야 해당 보호등급을 열었다고 할수있다.
public: 
    // 기본 생성자 // 매게변수로 아무것도 받지 않는 생성자
    E09();
    // 생성자
    E09(int aValue, int bValue);
    // 소멸자 // 앞에 ~이 있으면 소멸자
    ~E09();
    
    /*
    클래스는 사실 일종의 청사진(설계도,도면 등)에 가까우며 프로그래머가
    지정한 함수와 변수를 가지고잇는 객체를 찍어내기 위해 만들어두는 것
    이다보니, 해당 객체를 만들었다와 사라졌다는 담당할 함수가 필요하다.

    이러한 함수들을 생성자와 소멸자라 부르며, 생성자와 소멸자는 해당
    클래스의 이름과 동일한 이름을 가진 함수로 만들어진다.

    이때 반환값은 필요없다.

    그리고 생성자는 여러개 존재하는것이 가능한데, 이는 함수 오버로딩과
    같은 이유이다. 즉, 매게변수가 달라지면 생성자도 여러개 만들수있다.
    */

    // 기본적인 getter와 setter
    int GetA() { return aValue; }
    void SetA(int value) { aValue = value; }

    // this키워드는 자기 자신을 가리키는 포인터이다.
    // 쉽게말하면 자신의 주소를 알고있는 데이터라고 보면 된다.
    int GetB() { return this->bValue; }
    void SetB(int bValue) { this->bValue = bValue; }

    void ABSum();
    void ABMax();
    void ABMin();

private: // 여기부터는 private 영역

    // 사람마다 다르긴 하지만 보통 public에 함수를 넣고
    // private에 변수를 넣는다.

    int aValue = 0;
    int bValue = 0;
};
/*
과제! 길건너 친구들 만들기

조건1. 매 반복마다 장해물이 움직이는 맵 만들기
조건1_1. 맵은 2중 배열로 만든다. // 크기 자유 (최소 5x5)
# = 벽, @ = 플레이어, & = 장해물, % = 아이템
조건1_2. 매 반복때마다 장해물은 한쪽 방향으로 이동(좌우 만 가능)
조건1_3. 배열 끝에 도달한 장해물은 반대 방향으로 이동

조건2. 플레이어 제작
조건2_1. WASD로 이동, 벽은 지나길수 없음
조건2_2. 플레이어 체력 제작
조건2_3. 장해물과 닿을시 체력 감소 + 시작지점으로 이동
조건2_4. 아이템과 닿을시 체력 회복

조건3. 반대쪽 끝에 도달시 게임 승리 , 체력 0 이하가 될시 게임 패배

// 힌트
0. Windows.h 인클루드 하기

1. sleep 함수가 있음
1_1. sleep(1000);이라 입력하면 콘솔창이 1초간 멈췄다가 다시 움직임
1_2. sleep(500); 이라 입력하면 콘소창이 0.5초간 멈춤

2. system("cls"); 라고 치면 콘솔창 지울수 있음
*/