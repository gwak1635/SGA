#pragma once

#include "../Define/GlobalDefine.h"

/*
함수는 프로그램의 전체 혹은 일부를 그룹화 시켜서 따로 분리시킬 수 있는
기능을 의미한다.

이렇게 따로 분리시킨 코드는 필요할때 마다 불러와서 개별적으로 사용하는 것이
가능하다.

우리가 사용하고 있는 Main부터 각각의 E00 시리즈 또한 함수의 일부이다.

이러한 함수를 사용하기 위해선 함수가 내부에서 사용할 데이터를 건내주는
매게변수와, 함수가 내부에서 가공후 반환시킬 반환값이 필요한데

여기에 명시해준 매게변수와 반환값을 지키지 않을경우 에러가 발생한다.

Ex)
void AFun();        // void == 반환값이 없음, () == 매게 변수가 없음
// 즉, 아무것도 반환하지 않고 아무것도 받지 않아도 실행하는 함수

int bFun();         
// int == int형 데이터를 반환할 매게변수가 없는 함수
float bFun(int aValue) 
// float형 데이터를 반환하며 int형 매게변수를 요구하는
(해당 매게변수의 이름을 임시적으로 aValue라 지정한) 함수

이러한 방식으로 함수를 선언한뒤 위의 조건에 맞을경우 실행할 함수의 내용은
{}와 함께 작성이 되는데, 이때 선언과 내용을 적는 구현은 반드시 같이 있을
필요는 없다.

일반적으로 헤더 파일에서 함수들을 선언해준뒤 cpp파일에서 해당 함수의 내용을
구현한다.

이때 이러한 방식으로 구현을 하기 위해서는 반드시 cpp파일 위쪽에
헤더파일을 인클루드 해줘야 한다.

이런식으로 다양한 중괄호를 사용하다보단 중괄호 밖에서 만든 변수는
해당 중괄호 안에서 사용할수 있지만, 중괄호 안에서 만든 변수는
외부로 나갈수없는 일이 발생하는데

이는 컴파일러가 중괄호를 기준으로 지역을 나누기 때문이다.

지역 밖에 있는 (혹은 더 상위에 있는)데이터는 지역 안으로 들어가는것이
가능하지만 지역 안에서 만들어진 데이터들은 지역 밖으로 나가는 순간
컴파일러가 자동으로 해당 데이터를 지워버리기 때문에, 만약 특정 데이터를
외부로 빼고싶다면 외부에 해당 데이터를 담아둘 변수를 만들어 둬야 할것이다.

또한, 같은 이름의 변수가 지역의 밖과 안쪽에 선언됐다 하더라도 해당
지역 내부에서는 해당 지역에 있는 변수를 우선적으로 사용하는 특징도 있다.

Ex)
int aValue      // aVAlue--의 영향을 받는다.
{
    int aValue  // aValue++의 영향을 받는다.
    aValue++;
}
aValue--; 

함수가 내부에서 자기 자신을 불러오는 경우 또한 존재하는데,
이를 재귀 함수라 부른다.

재귀 함수는 말 그대로 자기 자신으로 돌아가는 함수이며 일종의 반복문과 유사한
특징을 지니고 있다.

단, 재귀 함수는 일반적인 반복문보다 조금 더 무겁고 재귀 함수 또한
반드시 재귀가 끝날 꼬리 재귀를 만들어 줘야하는 특징이 있다.

재귀 함수의 장점은 복잡한 코드를 여러번 반복해야 하며 데이터를 계속해서
가공해 원하는 값으로 변하게 만드는게 쉽다.

함수를 통해 전달한 매게변수는 원본이 아닌 해당 매게변수와 동일한 값을
가지고 있는 복사본이 내부에서 사용된다. 
// 즉 내부에서 1더한다고 원본이 1 더해지진 않는다.

그렇기 때문에 만약, 함수 내부에서 매게변수로 전달한 데이터의 원본을
수정하고 싶다면 해당 데이터의 자료형 뒤에 &(레퍼런스)를 붙여주면 된다.

&(레퍼런스)는 해당 데이터의 주소값을 반환시켜주는 기능이고 해당 주소를
건내주면 해당 주소를 복사해간 데이터가 해당 주소에 있는 값을 변경해주기 때문에
원본의 데이터가 수정된다.

이전에 자주 사용하던 scanf에서 &가 필요한 이유이다.
scanf또한 일종의 함수이고, 해당 함수에서 원하는 값을 우리가 넣어준 변수에
넣기 위해서는 &를 통해 해당 변수가 어디있는지 알려줄 필요가 있던 것이다.
*/

void E08();

void Up10Value(int temp1);

void RealUp10Value(int& temp1);

void SumValues(int temp1, int temp2, int& out);

void SumValues(int temp1, int temp2, int& out1, int& out2);